# 지하철 노선도 미션
[ATDD 강의](https://edu.nextstep.camp/c/R89PYi5H) 실습을 위한 지하철 노선도 애플리케이션

### step 1 - 단위 테스트 작성
1. 지하철 구간 관련 단위 테스트 완성하기
   1. 구간 단위 테스트 (LineTest)
   2. 구간 서비스 단위 테스트 with Mock (LineServiceMockTest)
   3. 구간 서비스 단위 테스트 without Mock (LineServiceTest)
2. 단위 테스트를 기반으로 비즈니스 로직 리팩터링 하기
3. 비즈니스 로직 리팩터링
   1. 구간 추가/삭제 기능에 대한 비즈니스 로직은 현재 LineService 에 대부분 위치
      1. 비즈니스 로직을 도메인 클래스(Line)으로 옮기기
   2. 리팩터링 시 LineTest 의 테스트 메서드를 활용하여 `TDD 사이클`로 리팩터링을 진행
   3. 리팩터링 과정에서 Line 이외 추가적인 클래스가 생겨도 좋음
      1. 구간 관리에 대한 책임을 Line 외 별도의 도메인 객체가 가지게 할 수 있음
         1. Line 이 List 형태로 가지고 있던 Section 을 Sections 라는 일급 콜렉션을 이용하여 분리함
4. step 1 피드백 리스트
   1. StationService -> StationRepository 로 했을 때의 side effect
   2. request 객체에 valid 함수를 생성! -> 이 경우 Service 레이어에서 검증하는데 이렇게 하기 보다는 요청을 받는 순간 검증을 하도록! -> spring validation 사용
   3. 구간을 등록할 때 (구간 등록시) 요구 사항 준수!
   4. Sections 에서 예외 사항을 자세하게 분리하는 방식!
   5. Sections 에서 지하철 노선에 상행 종점역과 하행 종점역만 있는 경우에 대한 예외 처리가 없다.
   6. LineTest 에서 하드 코딩보다는 전역 상수로 선언해보자!
   7. LineTest 에서 예외 케이스에 대한 검증 테스트도 같이 해보자!

### step 2 - 지하철 구간 추가 리팩터링
0. step 1 피드백
   1. Sections 에서 이미 사용되고 있는 모든 역을 가져오는 allStations() 메서드를 활용하여 duplicateStation 을 구현!
1. 기능 요구사항
   1. 추가된 요구사항 기반으로 `지하철 구간 관리 기능`을 리팩터링
   2. 추가된 요구사항을 정의한 `인수 조건`을 도출
   3. 인수 조건을 검증하는 `인수 테스트`를 작성
   4. 예외 케이스에 대한 검증도 포함
2. 프로그래밍 요구사항
   1. **인수 테스트 주도 개발 프로세스**에 맞춰서 기능을 구현
      1. `인수 조건`을 정의
      2. `인수 조건`을 검증하는 `인수 테스트` 작성
      3. 인수 테스트를 충족하는 `기능 구현`
   2. 인수 조건은 `인수 테스트 메서드 상단에 주석`으로 작성
      1. `뼈대 코드`의 인수 테스트를 참고
   3. **`인수 테스트 이후 기능 구현은 TDD 로 진행`**
      1. 도메인 레이어 테스트는 필수 (순수 도메인 테스트)
      2. 서비스 레이어 테스트는 선택 (Mock or without Mock)
3. 요구사항 설명
   1. 구간 추가에 대한 스펙, 요구사항이 변경되었다!
   2. `역 사이에 새로운 역`을 등록할 경우
      1. 기존역 A-C (7m), 새로운 역 A-B (4m)
      2. 이 경우 A-B-C 가 되며
      3. 각 구간의 길이는 A-B (4m), B-C (3m) 가 된다.
      4. 기존 구간의 길이는 새로운 구간의 길이의 뺀 값으로 설정된다.
      5. ex) 기존역 A-C (7m), 새로운역 B-C (4m) 도 가능하다.
      6. `기존 구간의 상행역`과 `신규 노선의 상행역`이 일치할 경우 `역 사이에 새로운 역` 등록 case
      7. 마찬가지로 `기존 구간의 하행역`과 `신규 노선의 하행역`이 일치할 경우 `역 사이에 새로운 역` 등록 case
   3. `새로운 역을 상행 종점`으로 등록할 경우
      1. 기존역 A-C (7m), 새로운 역 B-A (4m)
      2. 이 경우 B-A-C 가 되며
      3. 각 구간의 길이는 B-A (4m), A-C (7m) 가 된다.
      4. `기존 구간의 상행역`과 `신규 노선의 하행역`이 일치할 경우 `새로운 역을 상행 종점`으로 등록 case
   4. `새로운 역을 하행 종점`으로 등록할 경우
      1. 기존역 A-C (7m), 새로운 역 C-B (3m)
      2. 이 경우 A-C-B 가 되며
      3. 각 구간의 길이는 A-C (7m), C-B (3m) 가 된다.
      4. `기존 구간의 하행역`과 `신규 노선의 상행역`이 일치할 경우 `새로운 역을 하행 종점`으로 등록 case
   5. 노선 조회시 응답되는 역 목록 수정
      1. 구간이 저장되는 순서로 역 목록을 조회할 경우 순서가 다르게 조회될 수 있음!
      2. 아래의 순서대로 역 목록을 응답하는 로직을 변경해야 함
         1. `상행 종점이 상행역`인 구간을 먼저 찾는다.
         2. 그 다음, `해당 구간의 하행역이 상행역인 다른 구간`을 찾는다.
         3. 2번을 반복하다가 `하행 종점역을 찾으면 조회`를 멈춘다.
   6. 예외 케이스
      1. `역 사이에 새로운 역을 등록`할 경우 기존 역 사이 `길이보다 크거나 같으면` 등록할 수 없음
      2. `상행역과 하행역이 이미 노선에 모두 등록`되어 있다면 추가할 수 없음
      3. `상행역과 하행역 둘 중 하나도 포함되어있지 않으면` 추가할 수 없음

### step 3 - 지하철 구간 삭제 리팩터링
0. step 2 피드백
   1. Section 에서 자신을 가리키는 `this`를 사용하여 distance 를 더 명확하게 나타내주자
   2. Sections 에서 `sameNewAndExistingDownStation` 메서드에서 중복되는 로직이 있는데 줄일 수 있을 듯!
   3. Sections 에서 `validateAddSection` 에서 stream 하는 부분을 메서드로 추출하는 것도 좋아보임
   4. Sections 에서 `firstSection` 하는 메서드에서 elseThrow 에서 예외 메시지를 같이 던져주면 좋아보임
   5. RestControllerAdvice 와 ControllerAdvice 두 개를 따로 만든 이유?
      1. ControllerAdvice 에서 ResponseEntity 를 사용해도 ResponseBody 가 붙은 거처럼  작동하는지 몰랐습니다.
   6. 만든 CustomError 에 대한 부분이 아니더라도 다른 `5XX`, `4XX` 에러를 정의해 놓으면 `같은 에러 포멧으로 전달`해줄 수 있다.
   7. 미션을 진행하면서 비즈니스 로직의 추가에 따라 당연히 코드 라인이 늘어가는데 `가독성`을 신경써서 리팩터링을 진행하자
   8. 현성님의 방식
      1. `인수 테스트 작성`을 통해 요구사항과 기능 전반에 대한 이해를 선행
      2. 내부 구현에 대한 `설계 흐름`을 구상
      3. 설계가 끝나면 도메인부터 차근차근 TDD 로 기능 구현
1. 기능 요구사항
   1. step 2 와 동일
2. 프로그래밍 요구사항
   1. step 2 와 동일
3. 요구사항 설명
   1. 기존에는 마지막 역 삭제만 가능했는데 `위치에 상관 없이 삭제`가 가능하도록 수정
   2. 종점이 제거될 경우 다음으로 오던 역이 종점이 됨
   3. 중간역이 제거될 경우 재배치를 함
      1. 노선에 A-B-C 역이 연결되어 있을 때 B역을 제거할 경우 A-C로 재배치 됨
      2. 거리는 `두 구간의 거리의 합`으로 정함
4. 개발 전 내부 구현에 대한 `설계 흐름`
   1. DELETE /lines/1/sections?stationId=2
   2. `(Service Layer)` URL 에 있는 lineId PathVariable 을 통해 Line(노선)을 찾는다.
   3. `(Service Layer)` URL 에 있는 stationId RequestParam 을 통해 삭제하려는 Station(지하철 역)을 찾는다.
   4. `(Service Layer)` 찾은 Line(노선)에다가 stationId 를 통해 제거하고자 하는 Station(지하철 역)을 매개 변수로하여 구간 제거 (removeSection)라는 메시지를 보낸다.
   5. `(Line Domain Layer)` Line(노선)내에 있는 sections 에 구간 제거(removeSection)라는 역할을 위임하도록 또 Sections(구간 집합, 일급 콜렉션)에 메시지를 보낸다.
   6. `(Sections Domain Layer)` 여기서 비즈니스 로직을 구현한다.
      1. `(Exception)` 구간이 하나인 노선 (firstSection().equals(lastSection)) 이라면 제거할 수 없음
      2. `(Exception)` 노선에 등록되어 있지 않은 역을 제거할 수 없음
      3. `(Logic)` firstSection(), lastSection() 을 통해 상행인지, 하행인지 확인한다.
         1. 양 끝에 위치한 종점역이라면 별 다른 처리 없이 해당 Section(구간)을 제거하면 된다.
      4. `(Logic)` 양 끝에 위치한 종점역이 아니라면? 삭제하려는 역이 upStation 으로 등록된 Section 과 downStation 으로 등록된 2개의 Section 을 찾는다.
         1. 2개의 Section 중 상행인 Section 을 골라서 해당 Section 의 downStation 을 하행 Section 의 upStation 으로 값을 바꾼다.
         2. 또한, 상행인 Section 의 distance 에 하행 Section 의 distance 값을 `더하여 길이를 늘려준다.`
         3. 그 이후에 하행 Section 을 `List remove` 를 통해 제거해준다. (JPA Dirty Checking 을 통해 DELETE 메서드 수행)

### step 4 - 경로 조회 기능
0. 메서드 분리를 통한 가독성 증진
   1. Sections 에서 removeFirstOrLastSection(Station station) 메소드가 상행종점, 하행종점 역인지 판별하고
   2. 해당 Section 을 지워주는 역할을 하고 있는데, 함수가 사용되는 removeSection 의 가독성을 더욱 좋게 할 수 있어보임
   3. 상행종점, 하행종점, 중간역 인지 판별하는 역할과 section 을 지워주는 역할을 분리하면 좋아보임.
   4. 혹은 해당 역의 상태에 따라 구현되는 로직이 다르니 다자인 패턴을 생각해봐도 좋을 것 같다.
1. 기능 요구사항
   1. step 3 와 동일
2. 프로그래밍 요구사항
   1. step 3 와 동일
3. 요구사항 설명
   1. Request
      1. source: 출발역(Station) id
      2. target: 도착역(Station) id
      3. [GET] ~~~/paths?source=1&target=3
   2. Response
      1. stations: 출발역으로부터 도착역까지의 경로에 있는 역 목록
      2. distance: 조회한 경로 구간의 거리
4. 다익스트라 알고리즘 라이브러리 학습을 위한 학습 테스트를 참고!
5. 최단 경로 라이브러리를 숙지해야 한다.
6. 외부 라이브러리 테스트
   1. 외부 라이브러리의 구현을 수정할 수 없기 때문에 `단위 테스트를 하지 않음`
   2. 외부 라이브러리를 사용하는 직접 구현하는 로직을 검증해야 함
   3. 직접 구현하는 로직 검증 시 외부 라이브러리 부분은 `실제 객체를 활용`
7. 예외 상황 예시
   1. 출발역과 도착역이 같은 경우
   2. 출발역과 도착역이 연결되어 있지 않은 경우
   3. 존재하지 않은 출발역이나 도착역을 조회할 경우
8. 미션 수행 순서
   1. 인수 테스트 성공 시키기
      1. mock 서버와 dto 를 정의하여 인수 테스트 성공 시키기
   2. 기능 구현
      1. TDD 의 방향보다 테스트를 통해 `구현할 기능을 명세`하는것과 `리팩토링`이 더 중요하다!
   3. Outside In 경우
      1. 컨트롤러 레이어 구현 이후 서비스 레이어 구현 시 서비스 테스트 우선 작성 후 기능 구현
      2. 서비스 테스트 내부에서 도메인들간의 로직의 흐름을 검증, 이 때 사용되는 도메인은 mock 객체를 활용
      3. 외부 라이브러리를 활용한 로직을 검증할 때는 가급적 실제 객체를 활용
      4. Happy 케이스에 대한 부분만 구현 (Side 케이스 대한 구현은 다음 단계에서 진행)
   4. Inside Out 경우
      1. 도메인 설계 후 도메인 테스트를 시작으로 기능 구현 시작
      2. 해당 도메인의 단위 테스트를 통해 도메인의 역할과 경계를 설계
      3. 도메인의 구현이 끝나면 해당 도메인과 관계를 맺는 객체에 대해 기능 구현 시작

> 두 방향성을 모두 사용해보고 `테스트가 협력 객체의 세부 구현에 의존`하는 경우(가짜 협력 객체 사용)와 
> `테스트 대상이 협력 객체와 독립적이지 못하고 변경에 영향`을 받는 경우(실제 협력 객체 사용)를 모두 경험해보자! :)
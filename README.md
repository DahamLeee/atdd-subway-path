# 지하철 노선도 미션
[ATDD 강의](https://edu.nextstep.camp/c/R89PYi5H) 실습을 위한 지하철 노선도 애플리케이션

### step 1 - 단위 테스트 작성
1. 지하철 구간 관련 단위 테스트 완성하기
   1. 구간 단위 테스트 (LineTest)
   2. 구간 서비스 단위 테스트 with Mock (LineServiceMockTest)
   3. 구간 서비스 단위 테스트 without Mock (LineServiceTest)
2. 단위 테스트를 기반으로 비즈니스 로직 리팩터링 하기
3. 비즈니스 로직 리팩터링
   1. 구간 추가/삭제 기능에 대한 비즈니스 로직은 현재 LineService 에 대부분 위치
      1. 비즈니스 로직을 도메인 클래스(Line)으로 옮기기
   2. 리팩터링 시 LineTest 의 테스트 메서드를 활용하여 `TDD 사이클`로 리팩터링을 진행
   3. 리팩터링 과정에서 Line 이외 추가적인 클래스가 생겨도 좋음
      1. 구간 관리에 대한 책임을 Line 외 별도의 도메인 객체가 가지게 할 수 있음
         1. Line 이 List 형태로 가지고 있던 Section 을 Sections 라는 일급 콜렉션을 이용하여 분리함
4. step 1 피드백 리스트
   1. StationService -> StationRepository 로 했을 때의 side effect
   2. request 객체에 valid 함수를 생성! -> 이 경우 Service 레이어에서 검증하는데 이렇게 하기 보다는 요청을 받는 순간 검증을 하도록! -> spring validation 사용
   3. 구간을 등록할 때 (구간 등록시) 요구 사항 준수!
   4. Sections 에서 예외 사항을 자세하게 분리하는 방식!
   5. Sections 에서 지하철 노선에 상행 종점역과 하행 종점역만 있는 경우에 대한 예외 처리가 없다.
   6. LineTest 에서 하드 코딩보다는 전역 상수로 선언해보자!
   7. LineTest 에서 예외 케이스에 대한 검증 테스트도 같이 해보자!

### step 2 - 지하철 구간 추가 리팩터링
0. step 1 피드백
   1. Sections 에서 이미 사용되고 있는 모든 역을 가져오는 allStations() 메서드를 활용하여 duplicateStation 을 구현!
1. 기능 요구사항
   1. 추가된 요구사항 기반으로 `지하철 구간 관리 기능`을 리팩터링
   2. 추가된 요구사항을 정의한 `인수 조건`을 도출
   3. 인수 조건을 검증하는 `인수 테스트`를 작성
   4. 예외 케이스에 대한 검증도 포함
2. 프로그래밍 요구사항
   1. **인수 테스트 주도 개발 프로세스**에 맞춰서 기능을 구현
      1. `인수 조건`을 정의
      2. `인수 조건`을 검증하는 `인수 테스트` 작성
      3. 인수 테스트를 충족하는 `기능 구현`
   2. 인수 조건은 `인수 테스트 메서드 상단에 주석`으로 작성
      1. `뼈대 코드`의 인수 테스트를 참고
   3. **`인수 테스트 이후 기능 구현은 TDD 로 진행`**
      1. 도메인 레이어 테스트는 필수 (순수 도메인 테스트)
      2. 서비스 레이어 테스트는 선택 (Mock or without Mock)
3. 요구사항 설명
   1. 구간 추가에 대한 스펙, 요구사항이 변경되었다!
   2. `역 사이에 새로운 역`을 등록할 경우
      1. 기존역 A-C (7m), 새로운 역 A-B (4m)
      2. 이 경우 A-B-C 가 되며
      3. 각 구간의 길이는 A-B (4m), B-C (3m) 가 된다.
      4. 기존 구간의 길이는 새로운 구간의 길이의 뺀 값으로 설정된다.
      5. ex) 기존역 A-C (7m), 새로운역 B-C (4m) 도 가능하다.
      6. `기존 구간의 상행역`과 `신규 노선의 상행역`이 일치할 경우 `역 사이에 새로운 역` 등록 case
      7. 마찬가지로 `기존 구간의 하행역`과 `신규 노선의 하행역`이 일치할 경우 `역 사이에 새로운 역` 등록 case
   3. `새로운 역을 상행 종점`으로 등록할 경우
      1. 기존역 A-C (7m), 새로운 역 B-A (4m)
      2. 이 경우 B-A-C 가 되며
      3. 각 구간의 길이는 B-A (4m), A-C (7m) 가 된다.
      4. `기존 구간의 상행역`과 `신규 노선의 하행역`이 일치할 경우 `새로운 역을 상행 종점`으로 등록 case
   4. `새로운 역을 하행 종점`으로 등록할 경우
      1. 기존역 A-C (7m), 새로운 역 C-B (3m)
      2. 이 경우 A-C-B 가 되며
      3. 각 구간의 길이는 A-C (7m), C-B (3m) 가 된다.
      4. `기존 구간의 하행역`과 `신규 노선의 상행역`이 일치할 경우 `새로운 역을 하행 종점`으로 등록 case
   5. 노선 조회시 응답되는 역 목록 수정
      1. 구간이 저장되는 순서로 역 목록을 조회할 경우 순서가 다르게 조회될 수 있음!
      2. 아래의 순서대로 역 목록을 응답하는 로직을 변경해야 함
         1. `상행 종점이 상행역`인 구간을 먼저 찾는다.
         2. 그 다음, `해당 구간의 하행역이 상행역인 다른 구간`을 찾는다.
         3. 2번을 반복하다가 `하행 종점역을 찾으면 조회`를 멈춘다.
   6. 예외 케이스
      1. `역 사이에 새로운 역을 등록`할 경우 기존 역 사이 `길이보다 크거나 같으면` 등록할 수 없음
      2. `상행역과 하행역이 이미 노선에 모두 등록`되어 있다면 추가할 수 없음
      3. `상행역과 하행역 둘 중 하나도 포함되어있지 않으면` 추가할 수 없음

### step 3 - 지하철 구간 삭제 리팩터링
0. step 2 피드백
   1. Section 에서 자신을 가리키는 `this`를 사용하여 distance 를 더 명확하게 나타내주자
   2. Sections 에서 `sameNewAndExistingDownStation` 메서드에서 중복되는 로직이 있는데 줄일 수 있을 듯!
   3. Sections 에서 `validateAddSection` 에서 stream 하는 부분을 메서드로 추출하는 것도 좋아보임
   4. Sections 에서 `firstSection` 하는 메서드에서 elseThrow 에서 예외 메시지를 같이 던져주면 좋아보임
   5. RestControllerAdvice 와 ControllerAdvice 두 개를 따로 만든 이유?
      1. ControllerAdvice 에서 ResponseEntity 를 사용해도 ResponseBody 가 붙은 거처럼  작동하는지 몰랐습니다.
   6. 만든 CustomError 에 대한 부분이 아니더라도 다른 `5XX`, `4XX` 에러를 정의해 놓으면 `같은 에러 포멧으로 전달`해줄 수 있다.
   7. 미션을 진행하면서 비즈니스 로직의 추가에 따라 당연히 코드 라인이 늘어가는데 `가독성`을 신경써서 리팩터링을 진행하자
   8. 현성님의 방식
      1. `인수 테스트 작성`을 통해 요구사항과 기능 전반에 대한 이해를 선행
      2. 내부 구현에 대한 `설계 흐름`을 구상
      3. 설계가 끝나면 도메인부터 차근차근 TDD 로 기능 구현
1. 기능 요구사항
   1. step 2 와 동일
2. 프로그래밍 요구사항
   1. step 2 와 동일
3. 요구사항 설명
   1. 기존에는 마지막 역 삭제만 가능했는데 `위치에 상관 없이 삭제`가 가능하도록 수정
   2. 종점이 제거될 경우 다음으로 오던 역이 종점이 됨
   3. 중간역이 제거될 경우 재배치를 함
      1. 노선에 A-B-C 역이 연결되어 있을 때 B역을 제거할 경우 A-C로 재배치 됨
      2. 거리는 `두 구간의 거리의 합`으로 정함
4. 개발 전 내부 구현에 대한 `설계 흐름`
   1. DELETE /lines/1/sections?stationId=2
   2. `(Service Layer)` URL 에 있는 lineId PathVariable 을 통해 Line(노선)을 찾는다.
   3. `(Service Layer)` URL 에 있는 stationId RequestParam 을 통해 삭제하려는 Station(지하철 역)을 찾는다.
   4. `(Service Layer)` 찾은 Line(노선)에다가 stationId 를 통해 제거하고자 하는 Station(지하철 역)을 매개 변수로하여 구간 제거 (removeSection)라는 메시지를 보낸다.
   5. `(Line Domain Layer)` Line(노선)내에 있는 sections 에 구간 제거(removeSection)라는 역할을 위임하도록 또 Sections(구간 집합, 일급 콜렉션)에 메시지를 보낸다.
   6. `(Sections Domain Layer)` 여기서 비즈니스 로직을 구현한다.
      1. `(Exception)` 구간이 하나인 노선 (firstSection().equals(lastSection)) 이라면 제거할 수 없음
      2. `(Exception)` 노선에 등록되어 있지 않은 역을 제거할 수 없음
      3. `(Logic)` firstSection(), lastSection() 을 통해 상행인지, 하행인지 확인한다.
         1. 양 끝에 위치한 종점역이라면 별 다른 처리 없이 해당 Section(구간)을 제거하면 된다.
      4. `(Logic)` 양 끝에 위치한 종점역이 아니라면? 삭제하려는 역이 upStation 으로 등록된 Section 과 downStation 으로 등록된 2개의 Section 을 찾는다.
         1. 2개의 Section 중 상행인 Section 을 골라서 해당 Section 의 downStation 을 하행 Section 의 upStation 으로 값을 바꾼다.
         2. 또한, 상행인 Section 의 distance 에 하행 Section 의 distance 값을 `더하여 길이를 늘려준다.`
         3. 그 이후에 하행 Section 을 `List remove` 를 통해 제거해준다. (JPA Dirty Checking 을 통해 DELETE 메서드 수행)